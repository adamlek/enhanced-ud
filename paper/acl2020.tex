%
% File acl2020.tex
%
%% Based on the style files for ACL 2020, which were
%% Based on the style files for ACL 2018, NAACL 2018/19, which were
%% Based on the style files for ACL-2015, with some improvements
%%  taken from the NAACL-2016 style
%% Based on the style files for ACL-2014, which were, in turn,
%% based on ACL-2013, ACL-2012, ACL-2011, ACL-2010, ACL-IJCNLP-2009,
%% EACL-2009, IJCNLP-2008...
%% Based on the style files for EACL 2006 by 
%%e.agirre@ehu.es or Sergi.Balari@uab.es
%% and that of ACL 08 by Joakim Nivre and Noah Smith

\documentclass[11pt,a4paper]{article}
\usepackage[hyperref]{acl2020}
\usepackage{times}
\usepackage{latexsym}
\renewcommand{\UrlFont}{\ttfamily\small}

% This is not strictly necessary, and may be commented out,
% but it will improve the layout of the manuscript,
% and will typically save some space.
\usepackage{microtype}

%\aclfinalcopy % Uncomment this line for the final submission
%\def\aclpaperid{***} %  Enter the acl Paper ID here

%\setlength\titlebox{5cm}
% You can expand the titlebox if you need extra space
% to show all the authors. Please do not make the titlebox
% smaller than 5cm (the original size); we will check this
% in the camera-ready version and ask you to change it back.

\usepackage{subcaption}
\usepackage[capitalize]{cleveref}
\usepackage{tikz}
\usetikzlibrary{arrows,positioning,fit,shapes}
\usepackage{todonotes}
\usepackage{tikz-dependency}

\newcommand\BibTeX{B\textsc{ib}\TeX}

\title{How much of enhanced UD is contained in UD?}
% How enhanced is enhanced UD?

\author{First Author \\
  Affiliation / Address line 1 \\
  Affiliation / Address line 2 \\
  Affiliation / Address line 3 \\
  \texttt{email@domain} \\\And
  Second Author \\
  Affiliation / Address line 1 \\
  Affiliation / Address line 2 \\
  Affiliation / Address line 3 \\
  \texttt{email@domain} \\}

\date{}

\begin{document}
\maketitle
\begin{abstract}
  \todo{adam}
\end{abstract}

\section{Introduction}
% UD intro
Universal Dependencies (UD) is a syntactic annotation schema
focusing on representing shallow syntactic dependencies between
\emph{words}. One of the goals of UD has been to use it in
semantic downstream tasks, such as event extraction
\citep{fares20182018, mcclosky2011event} or
negation resolution \citep{fares20182018}.
%
However, the UD format restricts the shape of dependencies to a tree
structure.  This can be limiting, because semantics dependencies can
in principle exhibit any graph structure.

% EUD intro
To remedy this situation, the Enhanced Universal
Dependencies (EUD) schema was created. The goal of the schema is
to make certain semantic dependencies more explicit, such as
conjoined subject and object. The enhanced dependencies include
additional edges between words, aswell as augmented labels. For
example in enhanced dependencies, the conjunction relation also
include what type of conjunction is used, \textit{and, or, but}
and so on.

% What we do in this paper
In this paper we present our submission for the IWPT 2020 Shared
Task for parsing enhanced universal dependencies. The goal of the
task is to produce EUD graphs for all the basic dependency trees
in a set of treebanks from UD version 2.5.

This paper proposes to test the following hypothesis:
\begin{enumerate}
\item[(H1)] Most of the information provided by the EUD schema is
  contained in the UD schema.
\end{enumerate}

That is, if (H1) holds, then it is possible to map, algorithmically,
UD trees to EUD graphs.
%
Thus, we set out to implement such an algorithm. Concretely, we
construct a tree-to-graph transformation, which recognizes patterns in
the (basic) universal dependencies to derive enhanced dependencies.
%
More precisely, by running our algorithm on representative gold UD
data, we will be able to get a \emph{lower bound} on the amount of EUD
information contained UD (for these representative inputs).
%
Additionally, by running our algorithm after a state-of-the-art UD
parser, we will provide a baseline for the EUD reconstruction task.

%General idea: as described by the website
%(https://universaldependencies.org/u/overview/enhanced-syntax.html)
%for many cases, enhanced UD is a function of UD.

% Shared task introduction
Indeed, in the IWPT shared task, teams are asked to produce enhanced
dependencies from raw texts in 17 different languages. The
majority of the languages are indo-european with two notable
exceptions, Tamil (Dravidian) and Finnish (Uralic).

The task is evaluated using two metrics, ELAS and EULAS. ELAS
calculates the $F_1$-score over all enhanced dependencies, the
metric include both edges and edge labels. A secondary metric,
EULAS, is used which calculates the $F_1$-score over the edges
only.


% results in two lines
Our results show that (H1) is vindicated: we achieve an ELAS score of
$96.70$ and EULAS of $81.55$ on human-annotated dependency trees.  As
a baseline for the shared task, our method is also effective,
achieving an ELAS score of $67.85$ and an EULAS score of
$80.18$. (Thus loosing about $15$ percentage points when going through
a a machine-generation phase to obtain UD trees.)

\section{Method}
In essence, our method is to apply the tree rewrite recipies
provided in \citep{schuster2016enhanced} to transform basic UD
\emph{trees} into EUD graphs.

%To obtain basic UD trees for our system we use the universal
%dependency treebanks provided by the shared task organizers. From
%these we apply our method on basic UD trees from two sources:


    
\begin{itemize}
\item for each treebank we use the Stanford Biaffine Dependency
Parser \citep{dozat2016deep} provided in Stanza
\citep{qi2020stanza}.
\item
the development and gold trees in the treebanks, minus the enhanced
dependencies.
\end{itemize}

Then, we use a tree-matching procedure against the UD trees, and
locally insert edges corresponding to enhanced dependencies (and
sometimes delete unwanted edges). As a particular case, we may
re-label some edges. Once this is done, we convert the result back to
(enhanced) CONLL format.

Our system contain several patters described below. We first apply
all of the patterns that add or remove edges from the basic
tree. Here, we only apply the patterns on the basic tree and not
on enhancements made by any other pattern. After we've added the
new edges, we modify the edge labels and append the necessary
information.

Perhaps surprisingly, the patterns that we need to recognize are
simple, involving only three nodes. The two patterns to recognised are
shown in \cref{fig:patterns}. Essentially, we need to match on three
connected nodes.  We need to identify types of paterns. First, two
arcs forming a two-step path
(\cref{fig:pat-nsubj-conj,fig:pat-obl,fig:pat-rel}). We refer to this
style pattern as ``Type 1''.  Second, with two arcs pointing away from
a central node (\cref{fig:pat-aux-conj,fig:pat-xcomp}), refered to as
``Type 2''.
In both cases, we have additional constraints on the (edge) labels. Together, constraint
on graph topology and labels form patterns which we recognize and transform.
The exhaustive list of patterns and transformations follows.
\begin{enumerate}
\item Type 1 pattern with a relation label, which can be any of
  ``nsubj",``obj", ``amod", ``advcl",``obl", ``mark", ``nmod", followed by a
  ``conj'' label. (\cref{fig:pat-nsubj-conj}.) In this case we add an
  edge with the relation label to the other conjunct.
  %
  A full dependency tree containing this pattern can be found in \cref{fig:paul-and-mary}.
  \label{item:paul-and-mary}
\item Type 2 pattern with a a relation label being either ``nsubj'' or
  ``aux'', and a ``conj'' label. (\cref{fig:pat-aux-conj}.) We add a relation a relation label to
  the other conjunct, but only if the conjunct is not itself
  ``nsubj''. Indeed, if it were, then we are conjoining two full
  sentences and then there is no need for an enhanced dependency.
  %
  A full dependency tree containing this pattern can be found in \cref{fig:reading-or-watching}.
  \label{item:reading-or-watching}
\item Type 2 pattern with ``xcomp'' and ``nsubj''. Here we add an
  "nsubj:xsubj" edge. (\cref{fig:pat-xcomp}.)
\item Type 1 pattern, with ``acl:relcl" followed by a relation label
  which can be either ``nsubj",``obj",``obl",
  "advmod". (\cref{fig:pat-rel}.) The target node should also be a
  \emph{relative} pronoun, ie. it POS is ``PRON'' and its XPOS either
  ``WP'' (who, whom) or ``WDT'' (that, which). Indeed, this pattern is
  also found with other type of pronouns, but then it does not
  correspond to a relative clause.  In this case we add a ref edge to
  the pronoun and a (reverse) relation edge between the first and
  second node. The original relation edge is deleted. A full dependency
  tree of this pattern can be seen in \cref{fig:aclrecl}.
  \item Type 1 pattern, with a conjunction followed by a case
   marking. (\cref{fig:pat-obl}.) Exhaustively, the type of labels
   are ``case" followed by ``obl" or ``nmod"; ``cc" followed by
   ``conj", ``mark" followed by ``advcl" or ``acl". In this case we
   enhance the label with the lemma of the target node. This pattern
   can be seen in \cref{fig:rel-clause}.
\end{enumerate}

\begin{figure}[h]
    \centering
    \begin{dependency}
    \begin{deptext}[column sep=1em]
    Paul \& and \& Mary \& eat \& . \\
    \end{deptext}
    \depedge{1}{3}{conj:and}
    \depedge{3}{2}{cc}
    \depedge{4}{1}{nsubj}
    \deproot{4}{root}
    \depedge{4}{5}{punct}
    \end{dependency}
    \caption{Example sentence for pattern shown in \cref{fig:pat-nsubj-conj}}
    \label{fig:paul-and-mary}
\end{figure}

\begin{figure}[h]
    \centering
    \begin{dependency}
    \begin{deptext}[column sep=1em]
    She \& was \& reading \& or \& watching \& something  \\
    \end{deptext}
    \depedge{3}{1}{nsubj}
    \depedge[edge below]{5}{1}{nsubj}
    \depedge{3}{6}{obj}
    \depedge[edge below]{5}{6}{obj}
    \deproot{3}{root}
    \depedge{3}{2}{aux}
    \depedge[edge below]{5}{3}{aux}
    \depedge{3}{5}{conj:or}
    \depedge{5}{4}{cc}
    \end{dependency}
    \caption{Example sentence for pattern shown in \cref{fig:pat-aux-conj}}
    \label{fig:reading-or-watching}
\end{figure}

\begin{figure}[h]
    \centering
    \begin{dependency}
    \begin{deptext}[column sep=1em]
    John \& came \& from \& Paris  \\
    \end{deptext}
    \depedge{2}{1}{nsubj}
    \deproot{2}{root}
    \depedge{2}{4}{obl:from}
    \depedge{4}{3}{case}
  \end{dependency}
  \caption{Example sentence for pattern shown in \cref{fig:pat-obl}}
  \label{fig:john-paris}
\end{figure}


% advcl:mod example
\begin{figure*}[h]
    \centering
    \begin{dependency}
    \begin{deptext}[column sep=0.1cm]
    One \& answer \& is \& that \& the \& Pentagon \& prevented \& the \& State \& Department \& from \& running \& the \& CPA  \\
    \end{deptext}
    \depedge{2}{1}{nummod}
    \depedge{3}{2}{nsubj}
    \depedge{7}{4}{mark}
    \depedge{6}{5}{det}
    \depedge{7}{6}{nsubj}
    \depedge{3}{7}{ccomp}
    \depedge{10}{8}{det}
    \depedge{10}{9}{compound}
    \depedge{7}{10}{obj}
    \depedge{12}{11}{mark}
    \depedge{7}{12}{advcl:from}
    \depedge{14}{13}{det}
    \depedge{12}{14}{obj}
    \end{dependency}
    \caption{Example sentence for pattern shown in \cref{fig:pat-obl}}
    \label{fig:rel-clause}
\end{figure*}

\begin{figure}[h]
    \centering
    \begin{dependency}
    \begin{deptext}[column sep=0.1cm]
    Great \& Service \& and \& hairstyles \& that \& last  \\
    \end{deptext}
    \depedge{2}{1}{amod}
    \deproot{2}{root}
    \depedge{4}{3}{cc}
    \depedge{2}{4}{conj:and}
    \depedge{6}{4}{nsubj}
    \depedge{4}{5}{ref}
    \depedge[edge height=1.5cm]{4}{6}{acl:relcl}
    \end{dependency}
    \caption{Example sentence for pattern shown in \cref{fig:pat-rel}}
    \label{fig:aclrecl}
\end{figure}

    

\tikzstyle{word}=[] % [ellipse,draw=blue!50,fill=blue!20,thick]
\tikzstyle{deplabel}=[text=blue]%[rectangle,draw=blue!50,thick]
\tikzstyle{newedge}=[very thick]
\begin{figure}
\begin{subfigure}{\columnwidth}
  \centering
  \begin{tikzpicture}[inner sep=1mm]
    \node[word] (eat) {Eat};
    \node[word] (paul) [right=of eat] {Paul};
    \node[word] (mary) [right=of paul] {Mary};
    \draw[->] (eat) -- node[deplabel,above] {nsubj} (paul);
    \draw[->] (paul) -- node[deplabel,above] {conj} (mary);
    \path (eat) edge[->,newedge,bend right]  node[deplabel,below] {nsubj} (mary);
  \end{tikzpicture}
  \caption{Relation pointing to the conjuncts}
  \label{fig:pat-nsubj-conj}
\end{subfigure}

\begin{subfigure}{\columnwidth}
  \centering
\begin{tikzpicture}[inner sep=1mm]
  \node[word] (was) {was};
  \node[word] (read) [right=of was] {read};
  \node[word] (watch) [right=of read] {watch};
  \draw[->] (read) -- node[deplabel,above] {aux} (was);
  \draw[->] (read) -- node[deplabel,above] {conj} (watch);
  \path (watch) edge[->,newedge,bend left]  node[deplabel,below] {aux} (was);
\end{tikzpicture}

  \caption{Relation pointing away from the conjuncts.}
  \label{fig:pat-aux-conj}
\end{subfigure}

\begin{subfigure}{\columnwidth}
  \centering
\begin{tikzpicture}[inner sep=1mm]
  \node[word] (house) {house};
  \node[word] (look) [right=of house] {look};
  \node[word] (new) [right=of look] {new};
  \draw[->] (look) -- node[deplabel,above] {nsubj} (house);
  \draw[->] (look) -- node[deplabel,above] {xcomp} (new);
  \path (new) edge[->,newedge,bend left]  node[deplabel,below] {xsubj:nsubj} (house);
\end{tikzpicture}

  \caption{Xcomp special case}
  \label{fig:pat-xcomp}
\end{subfigure}

\begin{subfigure}{\columnwidth}
  \centering
\begin{tikzpicture}[inner sep=1mm]
  \node[word] (from) {from};
  \node[word] (paris) [right=of from] {Paris};
  \node[word] (come) [right=of paris] {come};
  \draw[->] (paris) -- node[deplabel,below] {case} (from);
  \draw[->] (come) -- node[deplabel,below] (lab) {obl} (paris);
  \node at (lab.south) {\textbf{obl:from}};
\end{tikzpicture}
  \caption{Label taken from other word (lemma)}
  \label{fig:pat-obl}
\end{subfigure}

\begin{subfigure}{\columnwidth}
  \centering
  \begin{tikzpicture}[inner sep=1mm]
    \node[word] (boy) {boy};
    \node[word] (live) [right=of boy] {live};
    \node[word] (who) [right=of live] {who};
    \draw[->] (boy) -- node[deplabel,above] {acl:recl} (live);
    \path  (live) edge[->,newedge,bend right] node[deplabel,above] {nsubj} (boy);
    \draw[->] (live) -- node[deplabel,above] {nsubj} (who);
    \path (boy) edge[->,newedge,bend right]  node[below,deplabel] {ref} (who);
  \end{tikzpicture}
  \caption{Relative clause}
  \label{fig:pat-rel}
\end{subfigure}

\caption{Implemented transformation patterns. Added elements are shown in bold.}
  \label{fig:patterns}
\end{figure}

\begin{figure}
\begin{subfigure}{\columnwidth}
  \centering
  \begin{tikzpicture}[inner sep=1mm]
    \node[word] (eat) {Eat};
    \node[word] (paul) [right=of eat] {Paul};
    \node[word] (mary) [right=of paul] {Mary};
    \draw[->] (eat) -- node[above] {nsubj} (paul);
    \draw[->] (mary) -- node[above] {conj} (paul);
    \path (eat) edge[->,newedge,bend right]  node[deplabel,below] {nsubj} (mary);
  \end{tikzpicture}
  \caption{Source pattern not representable in UD format}
  \label{fig:pat-nsubj-conj-bad}
\end{subfigure}

\begin{subfigure}{\columnwidth}
  \centering
\begin{tikzpicture}[inner sep=1mm]
  \node[word] (was) {was};
  \node[word] (read) [right=of was] {read};
  \node[word] (watch) [right=of read] {watch};
  \draw[->] (read) -- node[deplabel,above] {aux} (was);
  \draw[->] (watch) -- node[deplabel,above] {conj} (read);
  \path (watch) edge[->,newedge,bend left]  node[deplabel,below] {aux} (was);
\end{tikzpicture}

  \caption{Transformation pattern leading to a loss in performance}
  \label{fig:pat-aux-conj-bad}
\end{subfigure}
\caption{Transformation patterns \textbf{not} implemented.}
\end{figure}


% \begin{figure}[h]
%     \centering
%     \begin{dependency}
%     \begin{deptext}[column sep=0.5cm]
%     boy \& live \& who  \\
%     \end{deptext}
%     \depedge{1}{2}{acl:recl}
%     \depedge{2}{3}{nsubj}
%     \depedge[edge below,edge style={thick,blue!60}, edge horizontal padding=-3pt]{1}{3}{ref}
%     \depedge[edge below,edge style={thick,blue!60}]{2}{1}{nsubj}
%     \end{dependency}
%     \caption{alternative pattern design}
%     \label{fig:alt-p}
% \end{figure}


For patterns \cref{item:paul-and-mary,item:reading-or-watching}, the
conjunction dependency could conceptually be inverted, yielding two
other patterns (shown in
\cref{fig:pat-nsubj-conj-bad,fig:pat-aux-conj-bad}). However, we have
not implemented these patterns in our system. For the first pattern,
the reason is simple: it is not representable as a UD tree (a node
cannot have two parents). For the second pattern, applying it
results in a small loss in performance accross the board \todo{can we
  run this ?}, and thus it is best left inactive.

\section{Results}
(ADAM)

We present our official results for the shared task in
\cref{tab:test}. The scores are obtained by applying our tree-to-graph
transformation to dependency trees generated by the Stanford
Dependency Parser.

\begin{table}[h]
	\centering
	\begin{tabular}{l|rr}
		\textsc{Lang} & \textsc{ELAS} & \textsc{EULAS} \\
		\hline
		ar  & 51.26 & 75.62 \\
		bg  & 84.90 & 87.72\\
		cs  & 67.13 & 83.44 \\
		en  & 82.87 & 83.86 \\
		et  & 60.44 & 79.43 \\
		fi  & 65.96 & 83.30 \\
		fr  & 72.76 & 84.39 \\
		it  & 87.14 & 88.74 \\
		lv  & 66.01 & 80.60 \\
		nl  & 78.93 & 80.20 \\
		lt  & 52.56 & 67.37 \\
		pl  & 71.22 & 86.71 \\
		ru  & 70.37 & 88.02 \\
		sk  & 65.16 & 83.31 \\
		sv  & 71.35 & 73.84 \\
		ta  & 42.15 & 55.32 \\
		uk  & 63.24 & 81.24 \\
		\textbf{Avg.} & \textbf{67.85} & \textbf{80.18} \\
        \textbf{Std.} & \textbf{11.69} & \textbf{8.19} \\
	\end{tabular}
\caption{\label{tab:test} Coarse ELAS and EULAS on the languages in the test data.}
\end{table}

The scoring for unlabeled edges is typically around 80\%. The biggest
outlier being Tamil, at 55.32\%. The scoring for labeled edges is
around 12 points lower, with more variation in scores.

In order to isolate the accuracy of the graph-to-tree transformation
from the performance of the underlying UD parser, we also apply it to
the human annotated dependency trees. We test our approach on both the
development and test data. The results from this experiment is shown
in \cref{tab:gold-data}.

\begin{table}[ht]
	\centering
    \small
	\begin{tabular}{l|rrrr}
        & \multicolumn{2}{c}{\textsc{Dev}} & \multicolumn{2}{c}{\textsc{Test}} \\
		\textsc{Lang} & \textsc{ELAS} & \textsc{EULAS} & \textsc{ELAS} & \textsc{EULAS} \\
		\hline 
		ar & 66.44 & 96.38 & 64.14 & 96.55 \\
		bg & 94.32 & 96.95 & 94.55 & 97.01 \\
		cs & 75.65 & 94.63 & 76.52 & 95.12 \\
		en & 97.57 & 98.53 & 97.64 & 98.65 \\
		et & 73.35 & 93.96 & 72.30 & 95.53 \\
		fi & 74.22 & 95.29 & 74.40 & 95.12 \\
		fr & 83.59 & 97.93 & 88.15 & 99.05 \\
		it & 96.29 & 97.61 & 96.15 & 97.77 \\
		lt & 77.50 & 93.98 & 72.17 & 95.49 \\
		lv & 69.21 & 96.10 & 77.47 & 93.91 \\
		nl & 96.71 & 97.55 & 96.27 & 97.57 \\
		pl & 87.03 & 97.33 & 80.95 & 96.49 \\
		ru & 77.22 & 96.31 & 76.72 & 96.59 \\
		sk & 72.24 & 95.82 & 75.37 & 96.42 \\
		sv & 93.85 & 96.66 & 94.19 & 96.67 \\
		ta & 72.49 & 99.58 & 75.04 & 99.48 \\
		uk & 75.95 & 96.04 & 74.42 & 96.49 \\
		\textbf{Avg.} & \textbf{82.97}  & \textbf{96.53}& \textbf{81.55} & \textbf{96.70} \\
        \textbf{Std.} & \textbf{10.42} & \textbf{1.52} & \textbf{10.24} & \textbf{1.43} \\
	\end{tabular}
	\caption{\label{tab:gold-data}Coarse ELAS and EULAS on the gold trees in the development and test data.}
\end{table} 

The scoring for unlabeled edges is typically above 95\%, with little
variation. Tamil is no longer an outlier. The scoring for labeled
egdes can be classified in two categories depending on the
language. One category scores nearly as well as in the unlabeled case
(bg, en, it, nl, pl, sv). Another category scores about 15 points
lower (ar, cs, et, fi, lt, lv, ru, sk, ta, uk). French scores
somewhere in-between.

Comparing \cref{tab:test} and \cref{tab:gold-data} suggests
that our approach is very dependent on the underlying parser. In
addition to the ELAS and EULAS score being higher, the standard
deviation is also much highrer for EULAS, $8.19$ points in the test
versus $1.43$ points on the gold data.

\section{Discussion/Analysis}

We can draw the following conclusions from our experiments:

\begin{itemize}
\item
  Our pattern recognizer fails to annotate many labels
  for languages where case is expressed by morphological features.
  
  This is not surprising: we simply did not implement any rewriting
  based on such features. (Indeed, the pattern \cref{fig:pat-obl}
  recognizes case based on a preposition rather than a morphological
  feature.) This is a shortcoming which we plan to eliminate in future
  work.

  This shortcoming explains much of the discrepancy between the EULAS
  and the ELAS scores.
\item The performance of the system is heavily dependent on the
  quality of the UD parser which is used. This is also not surprising,
  since the rewriting step is algorithmic.

\item Our graph-to-tree transformation works well on the gold trees,
  missing less than 4\% of edges, when given gold UD trees as input.
  Therefore, Broadly speaking, (H1) is vindicated: UD contains most of
  the information which is necessary to reconstruct EUD graphs.

  We note however that (not enhanced) UD is incapable of expressing
  the difference between the structure of the following two sentences:
  
  \begin{itemize}
  \item[(1)] She was reading or watching a movie.
  \item[(2)] She was cleaning and eating fruits.
  \end{itemize}
  In (1) ``a movie'' is an object of a verb (``watching'') which is
  conjoined with another verb (``reading''), but it applies only to a
  single verb. In (2), we also have a conjunction between verbs, but
  ``fruits'' is the object of both verbs. Yet, the UD structure is the
  same for both sentence (TODO: these graphs?).  (And thus, our system
  cannot see the difference between the two.)  One solution is to use
  EUD, but another solution would be to use parse trees, which can
  make the grouping explicit.

  Figuring out which case applies depends on the semantics and
  pragmatics.

\end{itemize}

Even though we have shown that UD contains most information to recover
EUD, EUD annotations do have some additional value in certain
cases. However, because they have a more rich structure (graph
vs. tree), it may be that they are more suited as inputs to
machine-learning systems. Our systems can help testing this hypothesis
by inserting it (or not) in the pipeline of a state-of-the-art EUD
parser. If the EUD parser performs just as well with reconstructed EUD
data compared to human-constructed EUD data, then we'd know that
manual EUD annotations are not necessary.  It is likely that we'd have
a middle ground situation, where reconstructed EUD data helps, but
does not supplant human-constructed EUD. In such a situation, our
system can be useful as a bootstrapping tool. (We note however that
excellent EUD parsers are not available just yet; in fact they are the
purpose of the IWPT task which our system is entering.)

In addition to bootstrapping, a use of our system can be to provide a
baseline for such systems.  Indeed, while performing well on gold
data, our approach is transparent (only 5 patterns are applied) and
efficient, requiring a few seconds to generate enhanced graphs from a
treebank.

\paragraph{ Future work }
TODO: in a ddition to the short coming ...

Our system also struggles with labels that include multi-word
tokens. For example, a valid adverbial clause modifier is
\textit{so\_that}. To solve these label enhancements our system
would need either a complete list of multi-word tokens, or be
able to figure them out using statistical or deep learning.


%Our system will also struggle with multi-word labels such as:
%\textsc{advcl:so-that}. To solve these label enhancements a
%system would need either a complete list of these multi-word
%tokens, or be able to figure them out using statistical or deep
%learning

    
\section*{Acknowledgments}

(Anonymized)

\bibliography{anthology,acl2020}
\bibliographystyle{acl_natbib}


\end{document}
